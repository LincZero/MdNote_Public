NFV（Network Functions Virtualization）



所有跨主机通信几乎都会涉及网络协议栈以及底层网卡驱动对于数据包的处理。然而，低速网络和高速网络处理对系统的要求完全不一样

以Linux为例，传统网络设备驱动包处理的动作可以概括如下：

## IA不适合进行数据包处理吗？

1.   数据包到达网卡设备
2.   网卡设备依据配置进行DMA操作
3.   网卡发送中断，唤醒处理器
4.   驱动软件填充读写缓冲区数据结构
5.   数据报文达到内核协议栈，进行高层处理
6.   如果最终应用在用户态，数据从内核搬移到用户态
     如果最终应用在内核态，在内核继续进行

随着网络接口带宽从千兆向万兆买进，原先每个报文就会出发一个中断，中断带来的开销变得突出，大量数据到来会出发频繁的中断开销，导致系统无法承受，因此有人在Linux内核中引入**NAPI机制**，其策略是系统被中断唤醒后，尽量使用轮询的方式一次处理多个数据包，直到网络再次空闲重新转入中断等待。NAPI策略用于高吞吐的场景，效率提升明显。

...

一个二层以太网包经过网络设备驱动的处理后，最终大多要交给用户态的应用。

网络包进入计算机大多需要经过协议处理，在LInux系统中TCP/IP由LInux内核处理。即使在不需要协议处理的场景下，大多数场景下也需要把包从内核的缓冲区复制到用户缓冲区，系统盗用以及数据包复制的开销，会直接影响用户态应用从设备直接获得包的能力。
而对于多样的网络功能节点来说，TCP/IP协议栈并不是数据转发节点所必须的









































