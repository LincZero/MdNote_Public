# IO控制方式

## 提前总结

### 三种IO控制方式

三种方式：

- 轮询等待
  - 原理：**让CPU一直查**寄存器状态
  - 缺点：占CPU全部时间，效率低
- 中断 - 硬中断
  - 原理：设备中断到**硬件的中断控制器**，中断控制器再**通知CPU**。
    当中断产生后，CPU需要停下当前手里的事情来处理中断（插队式任务？）
  - 优点：不用占着CPU
- 中断 - 软中断
  - 原理：代码调用 `INT` 指令触发
  - 优点：(同)

- 直接内存访问 (DMA, Direct Memory Access)
  - 原理：需要有 「DMA 控制器」硬件的支持，将硬件到内存这一过程交给DMA，减少打断CPU和对CPU的使用次数。
  - 优点：硬件到内存这一过程，无需 CPU 参与
  - 结合中断使用：不互斥，结合中断使用。或者应该说，只是在前面中断的基础上，新增了直接内存访问个过程

## 两种通知CPU的方式

在前面我知道，每种设备都有一个设备控制器，控制器相当于一个小 CPU，它可以自己处理一些事情，但有个问题是，当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，它读完的时候，要怎么通知 CPU 呢？

### (1) 轮询等待

控制器的寄存器一般会有状态标记位，用来标识输入或输出操作是否完成。于是，我们想到第一种**轮询等待**的方法，让 CPU 一直查寄存器的状态，直到状态标记为完成，很明显，这种方式非常的傻瓜，它会占用 CPU 的全部时间。

### (2) 中断

那我们就想到第二种方法 —— **中断**，通知操作系统数据已经准备好了。我们一般会有一个硬件的**中断控制器**，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断。

另外，中断有两种，一种**软中断**，例如代码调用 `INT` 指令触发，一种是**硬件中断**，就是硬件通过中断控制器触发的。

## (3) 直接内存访问 (*DMA, Direct Memory Access*)

### 优点

但中断的方式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占用 CPU 大量的时间。

对于这一类设备的问题的解决方法是使用 **DMA（*Direct Memory Access*）** 功能，它可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I/O 数据放入到内存。那要实现 DMA 功能要有 「DMA 控制器」硬件的支持。

### 原理

![img](02.%20IO 控制方式.assets/DMA工作原理.png)

DMA 的工作方式如下：（序号和上图的序号一一对应。这个过程也用到了中断，是中断的基础上增加了 DMA 来处理磁盘到内存的拷贝）

1. CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；
2. 接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到其内部的缓冲区中；
3. 接着磁盘控制器将缓冲区的数据传输到内存；
4. 当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器；
5. DMA 控制器收到信号后，DMA 控制器发**中断**通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；

可以看到， CPU 当要读取磁盘数据的时候，只需给 DMA 控制器发送指令，然后返回去做其他事情，当磁盘数据拷贝到内存后，DMA 控制机器通过中断的方式，告诉 CPU 数据已经准备好了，可以从内存读数据了。仅仅在传送开始和结束时需要 CPU 干预。

