# 设备驱动程序

## 提前总结

### 总结

- 物理设备
  - **设备控制器**
    - 作用：**屏蔽设备差异**
    - 位置：硬件
  - 中断控制器
  - DMA 控制器
- 内核空间
  - **设备驱动程序** (操作系统位置)
    - 作用：**再屏蔽设备控制器差异**
    - 位置：操作系统的一部分

### 架构图

设备控制器 & 设备驱动程序 关系：

硬件 (设备 -> **设备控制器** -> **中断器控制器**) -> 内存空间 (**设备驱动程序** -> 操作系统其余部分) -> 用户空间 (用户程序)

![img](03.%20设备驱动程序.assets/驱动程序.png)

## 作用

虽然**设备控制器**屏蔽了设备的众多细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了**屏蔽「设备控制器」的差异**，引入了**设备驱动程序**。



- 设备控制器不属于操作系统范畴，它是属于**硬件**
- 而设备驱动程序属于**操作系统**的一部分，操作系统的内核代码可以像本地调用代码一样使用设备驱动程序的接口，而设备驱动程序是面向设备控制器的代码，它发出操控设备控制器的指令后，才可以操作设备控制器。

## 原理

### 如何统一接口

不同的设备控制器虽然功能不同，但是**设备驱动程序会提供统一的接口给操作系统**，这样不同的设备驱动程序，就可以以相同的方式接入操作系统。如下图：

![img](03.%20设备驱动程序.assets/驱动程序接口一致性.png)

### 中断流程

前面提到了不少关于中断的事情，设备完成了事情，则会**发送中断来通知操作系统**。那操作系统就需要有一个地方来处理这个中断，这个地方也就是在设备驱动程序里，它会及时响应控制器发来的中断请求，并根据这个中断的类型调用响应的**中断处理程序**进行处理。

![img](03.%20设备驱动程序.assets/中断工作过程.png)

- **设备驱动程序初始化时**，要先注册一个该设备的中断处理函数。
- **触发中断时**，处理流程为：
  1. 在 I/O 时，设备控制器如果已经准备好数据，则会通过**中断控制器**向 CPU 发送中断请求；
  2. 保护被中断进程的 CPU 上下文；
  3. 转入相应的设备中断处理函数；
  4. 进行中断处理；
  5. 恢复被中断进程的上下文；

## 【扩展】FAQ

（by Linc）

下面是个人的两个FAQ（这些是我以前刚刚学习陷入的误区或不肯定的地方）

### 为什么要分两次消除差异？

硬件 (设备控制器) 一次，操作系统 (内核, 设备驱动程序) 一次

我的个人理解是：

> - 首先硬件的设备控制器肯定要有的：不然每个硬件都对需要一个单独的驱动（你换个鼠标都要重新安装驱动）；
> - 然后操作系统的设备驱动也是要有的：如果苛求鼠标和显示器这种差异比较大的设备的控制器完全一样很难；
>
> 即：设备控制器更多是屏蔽差异小的同类同系列的硬件，驱动程序则屏蔽差异大的硬件

### 中断

#### 含义

“中断” 这个名字的字面含义 ：

> 在计算机科学中，**"中断"（Interrupt）是一个信号**，告诉操作系统暂停当前正在进行的任务，去处理一项更高优先级的任务。这个信号可以来自硬件（例如，输入设备）或者软件（例如，操作系统自身的服务）。
>
> 在Linux操作系统中，中断的概念也是类似的。它是一种机制，当某些事件（如硬件设备的输入/输出，定时器事件，或者其他系统事件）发生时，能够打断CPU当前的处理流程，让CPU去处理这些事件。这种机制使得计算机能够更有效地管理和响应各种不同的任务和请求。
>
> 例如，当你在键盘上按下一个键时，键盘会发送一个中断信号给操作系统。操作系统接收到这个信号后，会暂停正在处理的任务，转而处理这个键盘输入事件。处理完后，操作系统再返回之前被打断的任务继续执行。这就是为什么你可以在运行其他程序的同时输入文本。
>
> 所以，"中断"的字面含义就是"打断"或"中止"，但在计算机科学和Linux中，它具有特定的含义和用途，主要用于响应和处理系统事件。

#### 四种来源

中断信号的产生有以下4个来源：

1. **外设 (设备中断)**

   - 特点：*异步*、*硬件中断*

   - 举例：网卡、磁盘、定时器都可以产生硬件中断。

     设备准备好数据会产生这种中断。这也是 “设备管理” 这一个大章所描述到的中断

2. **CPU**

   - 特点：*异步*、一种特殊的*硬件中断*
   - 这里指的是一个CPU向另一个CPU发送中断，这种中断叫做IPI (处理器间中断)。IPI也可以看出是*一种特殊的硬件中断*，它和硬件中断的模式差不多

3. **中断指令**

   - 特点：*同步*、*软件中断*。直接用CPU指令来产生中断信号，这种中断和CPU异常一样是同步的，也可以叫做软件中断

   - 举例：中断指令int 0x80可以用来实现系统调用。

     应用程序使用系统调用时，会产生一个中断。一般是软中断

     发生中断后， CPU  会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU  执行权限交回给用户程序，回到用户态继续工作。

4. **CPU异常**

   - 特点：*同步*、*软件中断*

   - CPU在执行指令的过程中发现异常会向自己发送中断信号，这种中断是同步的，一般也叫做软件中断(注意软中断是另外一个概念)。

     CPU异常按照是否需要修复以及是否能修复分为3类：

     1. 陷阱 (trap)，不需要修复，中断处理完成后继续执行下一条指令
     2. 故障 (fault)，需要修复也有可能修复，中断处理完成后重新执行之前的指令
     3. 中止 (abort)，需要修复但是无法修复，中断处理完成后，进程或者内核将会崩溃

   - 举例：缺页异常是一种故障，所以也叫缺页故障，缺页异常处理完成后会重新执行刚才的指令。



补充：

（很多书上也把硬件中断叫做中断，把软件中断叫做异常）

（硬件中断按照是否可以屏蔽分为*可屏蔽中断和不可屏蔽中断*）

（有个资料说硬件中断不等于硬中断，那是另外一个概念，但我查了没找到相应的说法，都说是一样的）

#### 【比较】设备中断 & 中断指令，如何理解后者

这里以这两种为例：设备中断 & 中断指令，列一下**区别**：

| 设备中断 | 中断指令 |
| -------- | -------- |
| 异步     | 硬件中断 |
| 同步     | 软件中断 |



这两种的区别还是比较大的，可能要区分一下。我们具体说一下第二种中断 —— 系统调用的中断指令：

> 这里的理解要绕一下弯。
>
> 这里的 “中断” 会打断原来的CPU用户态工作，但要执行的中断程序其实也是要执行任务的一部分。
>
> 即 “一个完整任务A”  = “用户态程序B1” + “内核态程序C” + “用户态程序B2” 组成。
>
> - 从CPU上下文的角度来看：是执行程序B的过程中被C打断了，去处理完程序C再回来继续处理程序B
> - 但从完整任务的角度来看：这个完整任务A正在根据步骤一步一步完成，没有被打断

#### 插队式

这可以理解为一种 ”插队“ 的进程调度，而非 ”非插队“ 的

- "插队" 优点：确保系统能够及时响应这些事件
- “插队” 缺点：导致性能损耗较大。所以经常会使用缓冲和DMA机制尽可能减少中断次数

#### “中断” 是专用术语而非通用词 (Interrupt)

”中断“ 是专用术语而非字面意义上的通用词，即 **并非只要字面意思的 “打断” 就能称之为 “中断”**，而是特指的是 “中断信号” 产生的 “中断”

- 设备数据准备好后，任务恢复时通过 “中断信号” 打断CPU现在进行的工作，**这是 “中断”**
- 用户态系统调用时主动发送中断指令，让CPU执行内核态的程序任务，**这是 “中断”**
- 而CPU通知设备后不阻塞而去干其他事情，则**不能称之为 ”中断“**，这里没有 “中断信号的产生”





