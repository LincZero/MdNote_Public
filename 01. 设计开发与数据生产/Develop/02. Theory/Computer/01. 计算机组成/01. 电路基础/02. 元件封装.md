# ComputerSystems

# 目录

# 元件封装

## 【元件】ALU

### 【元件】半加器、全加器、加法器

思路：先把加法值和进位值两个真值表列举出来，然后判断出分别是异或门和与门

| 封装元件 | 元件接口 (输入)                  | 元件接口 (输出)            | 实现方法                                                     |
| -------- | -------------------------------- | -------------------------- | ------------------------------------------------------------ |
| 半加器   | 两个一位加数<br />(x, y)         | 和与进位<br />(sum, carry) | x⊕y=加法值，x*y=进位值，封装得到半加器                       |
| 全加器   | 三个一位加数<br />(x, y, 进位值) | 和与进位<br />(sum, carry) | 通过两个半加器和一个或门得到全加器<br />全加器的输入接口多了一位是为了处理仅为 |
| 加法器   | 两个n位加数<br />(X, Y)          | 和 (可能溢出)<br />(SUM)   | 多个全加器串联封装得到加法器（第一个加法器的第一个全加器进位值为0） |
| 现代方案 | ——                               | ——                         | 以上是脉冲进位的加法器，位数越多越慢！<br />现在的计算机使用的是前置进位，速度更快   现代也不使用续电器，使用的是晶体管 |

#### 减法

也是使用加法器来补充，补码运算

略

#### 加法器的一些附加电路

加法器除了计算和，还需要判断一些东西，有一些额外的附加电路

- 溢出：进位/carry是否为1
- 判零电路：记录记过是否为0，实现：用或门两两判断
- 负值：记录结果是否为负值
- 奇偶：看结果最后一位是否为0
- 进位：记录计算过程中的借位/进位

### 【元件】连续加法器

需要使用寄存器

### 【元件】ALU / 算术逻辑单元（Arithmatic Logic Unit）

- 实现：ALU 算术逻辑单元 = 计算单元 + 逻辑单元
- 功能：既能做逻辑判断，也能做加减乘除
- 符号表示：`V`
- **元件接口**
  - 输入
    - 两个八位的输入，(X, Y)
    - 一个四位的操作码 (运算符 / Operation / 计算机指令)，例如1000代表加，(O)
  - 输出
    - 一个八位的输出，(Z)
    - (状态 / Status)，例如输出结果是否或负值等逻辑状态，(S)
- 历史扩展
  - 世界上第一个封装到单芯片的ALU，是Intel 74181芯片，使用了70个晶体管，是一个4位的ALU

## 【元件】寄存器

- 核心思路：将输出接到输入

### 简单锁存器

或门的输出接到输入二，当输入一通电再断电时，或门的输出却依然为1

### 按需锁存器

按需保存，当Reset接通后就不能保存且会清空保存的数据

缺点：一次只能存一位，存储量高时耗费资源大。如果要存储8位，则**输入接口需要有18根线控制**

![image-20211107162138325](02. 元件封装.assets/锁存器.png)

### 【元件】SRAM，静态随机访问存储（寄存器）

左上是一把锁，当锁入时则不同写入。左下是使能

- 存储器：静态随机访问存储 SRAM（Static Random Access Memory）
- 改进点：当要保存8个位时，可以让这8个电路共用同一把锁，**输入接口仅有9根线**
- 优点：执行速度快（纯逻辑门）
- 缺点：怕断电
- 成本：存储1位需要6个逻辑门、10个晶体管、占用面积大
- 场景：寄存器，若用于内存则成本非常高，内存一般使用的是DRAM
- 数量级：KB级别

![image-20211107162709704](02. 元件封装.assets/image-20211107162709704.png)

### 【元件】DRAM，动态随机访问存储（内存）

原理上电容存储数据，但电容会漏电，需要定时进行充电才能保证数据不丢失，定期充电称之为`刷新`。这也是名字上`动态`的来源

- 存储器：动态随机访问存储 DRAM（Dynamic Random Access Memory）

### 【元件】寻址器

地址线：寻址

略

## 【元件】CPU

### CPU构成

- ALU
- 4个通用8位寄存器ABCD（计算过程使用）
- CU 控制单元（Control Unit）
  - IP 专用寄存器（用于存储指令地址）
  - IC 专用寄存器（用于计数）
  - 解码器（接受四位指令）

### 制定一些简单指令

| 指令    | 代码 | 功能                            |
| ------- | ---- | ------------------------------- |
| LOAD_A  | 0000 | 将指定内存地址数据加载至寄存器A |
| LOAD_B  | 0001 | 将指定内存地址数据加载至寄存器B |
| ADD     | 0100 | 将指定两个寄存器数据相加        |
| STORE_A | 1000 | 将寄存器数据存储至制定内存地址  |

### 解码电路

功能：判断指令是否为制定指令（例如0001），是则输出1

### 原理

冯诺依曼架构计算机（存储程序计算机）

以CU为核心来看：CU与ALU通信，CU即可以选择直接或通过寄存器间接地与内存通信

![image-20211107165926897](02. 元件封装.assets/CPU原理.png)

IO流

<img src='https://g.gravizo.com/svg?
@startuml;
rectangle Memory;
rectangle ControlUnit;
rectangle ALU{;
  rectangle Accumulator;
};
rectangle Input;
rectangle Output;
Memory-->ControlUnit;
ControlUnit-->Memory;
Memory-->ALU;
ALU-->Memory;
ControlUnit->ALU;
ALU->ControlUnit;
Input->Accumulator;
Accumulator->Output;
@enduml
'>

### CPU接口

CPU背后很多金属触点（引脚）：供电来源、地址线、数据线等

## 【元件】计算机

### 【元件】主板

将CPU、内存、硬盘、屏幕、鼠标键盘等连接在一起

电脑和手机都有主板

### 整体连接

补充：其中IC表示时钟，当供电后就算还没开始时IC也在工作（这里的IC和CPU里面的IC好像不同）

补充：CPU和内存之间还有高速缓存，此图略

![image-20211107191333848](02. 元件封装.assets/计算机主板.png)

### 开机过程

- 通电部分：通电 -> IC时钟 -> 开机 -> 电源通入主板并检查有没有短路漏电等判断是否要切断电源输出 (电源的自动保护) -> 电源发出一个PowerGood信号
- 主办和CPU部分：时钟芯片的RST (RESET) 端收到这个信号 -> 向主板发出各种信号 -> CPU时钟电路打拍子 -> CPU进行复位工作 (比如初始化IC和IP等)

### 【元件】ROM

#### 作用

- 刚开机的时候内存是空的，那CPU拿执行什么指令？
  预先内置在计算机中ROM (保存指令且断电不消失) 芯片的程序
  CPU以访问内存的方式来访问ROM，并不需要Load指令，初始化后的IP会强制地指向ROM假装内存的位置
- 当不插内存时
  虽然没内存也能读取ROM的指令，但当CPU执行ROM的第一条指令后会开始一个`开机自检 (POST, power on self test)` 的工作
  检测到内存这种关键部件不存在时会自检失败

#### ROM程序、BOOT、引导程序

- ROM指令集
  指令有很多，`BIOS (基本输出输出程序)` 里的程序就是ROM的指令合集
  后来升级了一次，叫`UEFI`，升级为UEFI是为了统一接口
- BOOT (开机启动程序) 
  名字来源：鞋带bootstrap，指这个程序像鞋带将计算机拉起来一样拉起计算机系统
  是BIOS里的一个菜单或一个功能 (bootmenu)，是开机启动程序
  ROM最重要的指令之一是提供了在硬盘中寻找程序的方法，可以将它找到的程序送到内存中执行，此时计算机才算真正运行起来了
- 引导程序
  严格意义上说，在硬盘中寻找程序是在找一个叫`BootLoader 引导程序`的程序，并加载到内存中的特定位置`0x7c 00`

## （旧）真空管版本

### 反馈和振荡器

用续电器控制“控制自己的开关”，则得到循环脉冲。输出影响输入的过程，称为反馈

这种电路称为振荡器，振荡脉冲也被称为时钟信号/时钟脉冲。

蜂鸣器，电铃原理

参数：频率（Hz=脉冲/s），周期（1/Hz）

### D型触发器

> 基础电路1原理：
>
> ​	或非门（有1则0，电路抽象为月加圆型），反馈
>
> 基础电路1真值表：
>
> ​	10得1，01得0，00看上一次结果
>
> ​	11理论得0但不讨论，用这个触发器时不会出现11
>
> 基础电路1特点：
>
> ​	或非1可存储上一次计算结构，有“记忆”的特点

基础记忆电路1，构造如下

> **算了，MarkDown画不出来**

| 上次输出 | 或非1 |      |      |
| -------- | ----- | ---- | ---- |
| x        | 或非2 | 输出 |      |
| y        | ——    |      |      |

上面电路改造封装后为D型触发器

> D型触发器，又名D型锁存器，1位存储器 封装后，输入为数据端和触发端，输出为存储端 真值表    （输入1和！输入1：10得1，01得0）    输入2为触发端，决定更改or保留数据端输入1 即：if y then x

D型触发器构造

| 输入1（原y）                      | 与           |      | 上次输出 | 或非1 |      |      |
| --------------------------------- | ------------ | ---- | -------- | ----- | ---- | ---- |
| 输入2(1时结果不变)(0时结果为上次) | 输入1（原x） | ——   | 或非2    | 输出  |      |      |
| 与                                | 输入2（原y） | ——   | ——       |       |      |      |
| ！输入1（原y）                    |              |      |          |       |      |      |

### 边沿触发

> D型触发器会【一直触发】（触发端为1时） 边缘触发器在D型触发器的基础上搭建出来的，分上升沿和下降沿触发器 边沿触发器特点    两个D型触发器串联，但同一时间只能有一个D型触发器被触发    即：上升沿边缘触发器只有在触发端从0变成1的时候（右侧D被激活，左侧关闭）存储数据【不会一直触发】

边沿触发器结构（上升沿）（下降沿则吧非门往下移一个位置）

| 数据端 | ——   | D型触发器1 |      |      |
| ------ | ---- | ---------- | ---- | ---- |
| 触发端 | 非   | D型触发器2 | 输出 |      |
| ——     | ——   |            |      |      |

### RAM存储器

RAM存储器的三个基本规则

- 【写入和读取】使用的存储数据的容器口【只有一个】且【不能同时】进行
- 写入和读取也统称为访问，这个结构编程术语称为栈

用D型触发器改造成RAM存储器

- 原D型存储器的输入和输出是两个口，且无法控制读写
- 改造1：把D型的数据端和输出端合并为一个口：数据端
- 改造2：从原来的一个控制端”写“，再增一个控制端”读“并控制电路
  【即：1输入端1输出端1控制端>>>1访问端2控制端】

RAM存储器真值表

- R0W0时，存储器和续电器均断开，均不工作
- R0W1时，存储器工作：写入操作；续电器断开：不读数据
- R1W0时，存储器乱开：不做工作；续电器联通：把存储数据通向外部

用D型触发器改RAM存储器

| D(读写数据) | 1位存储器        |                 |               |      |
| ----------- | ---------------- | --------------- | ------------- | ---- |
| W（写）     | （存储数据输出） | 续电器（R控制） | D（读写数据） |      |
| R（读）     | ——               | ——              |               |      |

> 多位存储器
>
> - 8个1位存储器的并联，W端和R端分别接在一起，同时读取，就是一个8位存储器    4个8位存储器排列一起，就是一个32位RAM存储器。但同一时间只能对一层存储器进行操作
> - 这里的一层就是一个存储单元，第几层就是一个地址。目前【最小的存储单元】是8位（1字节） 用地址码拓展多位存储器
> - 用地址码通过地址译码器的输出结果来控制对存储器的哪一地址的存储单元进行读写
>   32位地址码（4字节）则可表达43亿个地址，控制43亿个存储单元。假如每个存储单元1字节
>    则一共可存储4GB大小容量（2^32）/（2^10^3） 存储器引线    两个控制端（WR）
> - 地址引线（表示可访问存储单元的数量）    数据引线（表示同一时间可对多少位的数据进行读写访问）
>   （根据后两者可推算出存储容量）
>
>  RAM特点及原理
>
> - 速度快：寻址快，读写控制快
> - 怕断电：RAM由门电路组成的D型触发器组成，而门电路依赖电力驱动
> - 当断电时，续电器所控制的所有开关瞬间全部回复到初始状态，数据不复存在 译码器（地址译码器为例）
> - 搭建思路：先确定需求，用真值表反推布尔函数（同一时间仅一行输出为1，反推较容易）

### 寄存器

**一般寄存器**

> 一般寄存器结构    使用原生的D型触发器，直接进行并联（RAM存储器是用改造的D型触发器并联）    将8个D型触发器的控制端连在一起，封装得到8位寄存器 RAM存储器和一般寄存器结构区别    8为RAM存储器：8访问端2控制端    8位一般寄存器：8输入端8输出端1控制端

**循环移动位寄存器**（上升触发器为例）

> 结构    把8个上升沿触发器的控制端连在一起    但区别为8个触发器的数据端和存储端依次相连，且首尾相接（形成环）    触发器与触发器相连的地方暴露出去，形成8个访问端 特点    每次触发时，8个寄存器进行一次循环移位    这种寄存器不能使用D型触发器，否则移位的速度不可控    用边沿触发器可以控制移位速度 封装后    8位循环移动寄存器：8输出端1控制端，且控制端连接振荡器

### 连续加法器

> 主要用加法器和触发器搭建而来，搭建思路：    改造步骤1：加法器输入端1和输入端2共享数据信号源，用输入端1加一个边缘触发器进行锁存    改造步骤2：将加法器输出端与数据信号源相接（不行）        自动循环。而且同一条总线不能有多个信号，会产生数据冲突    改造步骤3：数据源后和加法器后加入锁存器，解决数据冲突

连续加法器结构：

|        | D型触发器GA | 输入端1 | 边缘触发器RA | 加法器      |           |      |      |
| ------ | ----------- | ------- | ------------ | ----------- | --------- | ---- | ---- |
| 数据源 | 输入端2     | ——      | 边缘触发器TR | D型触发器GB | （联通1） |      |      |
|        | （联通1）   |         |              |             |           |      |      |

> 连加步骤：    1.加载：激发GA，RA，传入第一个数据    2.相加：激发GA，TR，传入第二个数据，流入加法器得到结果，并被锁存    3.结果加载：激发GB，RA，传入结果数据    然后不断重复步骤2、3进行连加

### 连续加法器的简化

**译码器真值表：**

| 操作     | 输入  | 输出 |      |      |      |      |      |      |
| -------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| K加载    | K相加 | K0   | K1   | GA   | RA   | TR   | GB   |      |
| 加载     | 1先   | 0    | 1后  | 0    | 1先  | 1后  | 0    | 0    |
| 相加     | 0     | 1先  | 1后  | 0    | 1先  | 0    | 1后  | 0    |
| 结果加载 | 0     | 1先  | 0    | 1后  | 0    | 1后  | 0    | 1先  |

> 加入一个连续加法器的译码器，结构如上，主要简化第3步后的操作 根据译码表需求，用反推公式得到布尔函数，根据布尔函数搭建译码器

### 先后问题

> K0和K1的输入在10和01之间不断循环，所以可以在前面加一个循环移位寄存器RR，来自动处理 循环移位寄存器前置一个按钮K，用来替换原按钮K1和K2 K往后接，与RA和TR分别连一个与门运算，从而让RA和TR的输出产生延迟，从而解决先后问题

### 先存储再计算

> 题外话    RAM存储器（内存，主存），在冯诺依曼架构中属于硬件中的存储器，而硬盘属于IO设备    这才是本质区别，而非结构上的区别是本质区别

### 全自动计算

### 计算机的选择



