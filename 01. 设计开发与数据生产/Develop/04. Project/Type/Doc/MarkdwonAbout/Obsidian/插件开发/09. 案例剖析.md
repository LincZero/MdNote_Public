# Obsidian

# ç›®å½•

# å¸¸ç”¨å·¥å…·æ‰‹å†Œ

## Pluginç±»

```js
import { Plugin } from "obsidian";

export default class ExamplePlugin extends Plugin {
  async onload() {
    // highlight-next-line
    console.log('loading plugin')
  }
  async onunload() {
    // highlight-next-line
    console.log('unloading plugin')
  }
}
```





## CodeMirror5

ä¸ç¼–è¾‘å™¨æ‰©å±•é€šä¿¡

```typescript
import { EditorView } from "@codemirror/view";

// @ts-expect-error, not typed
const editorView = view.editor.cm as EditorView;

```





```typescript
this.addCommand({
  id: "example-editor-command",
  name: "Example editor command",
  editorCallback: (editor, view) => {
    // @ts-expect-error, not typed
    const editorView = view.editor.cm as EditorView;

    const plugin = editorView.plugin(examplePlugin);

    if (plugin) {
      plugin.addPointerToSelection(editorView);
    }
  },
});

```





æ‚¨å¯ä»¥åœ¨ç¼–è¾‘å™¨è§†å›¾å†…ç›´æ¥æ´¾å‘å˜åŠ¨ä»¥åŠ[state effects](https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh2.0/editor/extensions/state-fields.html#dispatching-state-effects)ã€‚

```typescript
this.addCommand({
  id: "example-editor-command",
  name: "Example editor command",
  editorCallback: (editor, view) => {
    // @ts-expect-error, not typed
    const editorView = view.editor.cm as EditorView;

    editorView.dispatch({
      effects: [
        // ...
      ]
    });
  },
});

```



#### å°éƒ¨ä»¶

å°éƒ¨ä»¶æ˜¯æ‚¨æ·»åŠ åˆ°ç¼–è¾‘å™¨ä¸­çš„è‡ªå®šä¹‰ HTML æ ‡ç­¾ã€‚æ‚¨å¯ä»¥åœ¨æ–‡æ¡£ä¸­çš„ç‰¹å®šä½ç½®æ’å…¥ä¸€ä¸ªå°éƒ¨ä»¶ï¼Œæˆ–è€…ç”¨ä¸€ä¸ªå°éƒ¨ä»¶æ›¿æ¢ä¸€æ®µå†…å®¹ã€‚

ä¸‹ä¾‹ä¸­å®šä¹‰äº†ä¸€ä¸ªè¿”å› `<span>ğŸ‘‰</span>` HTML æ ‡ç­¾çš„å°éƒ¨ä»¶ã€‚æ‚¨å°†åœ¨ç¨åä½¿ç”¨åˆ°å®ƒã€‚

```tsx
import { EditorView, WidgetType } from "@codemirror/view";

export class EmojiWidget extends WidgetType {
  toDOM(view: EditorView): HTMLElement {
    const div = document.createElement("span");

    div.innerText = "ğŸ‘‰";

    return div;
  }
}
```

è¦æƒ³ä½¿ç”¨ emoji å°éƒ¨ä»¶æ›¿æ¢æ‚¨æ–‡æ¡£ä¸­çš„ä¸€éƒ¨åˆ†å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨[æ›¿æ¢è£…é¥°](https://codemirror.net/docs/ref/#view.Decoration^replace)ã€‚

```tsx
const decoration = Decoration.replace({
  widget: new EmojiWidget()
});
```



# æ’ä»¶æ¡ˆä¾‹å‰–æ

## çº¯Obsidianæ¥å£

### List-Callout

æ¯”è¾ƒç®€å•

```tsx
// è¶…ç®€åŒ–ç‰ˆä»£ç 
export default class ListCalloutsPlugin extends Plugin {
    async onload() {
        await this.loadSettings();
        this.buildPostProcessorConfig(); // åå¤„ç†å™¨çš„é…ç½®
        this.addSettingTab();	// è®¾ç½®
        this.registerMarkdownPostProcessor(); // mdåå¤„ç†å™¨ï¼ˆæ¸²æŸ“æ¨¡å¼ç”¨ï¼‰
        this.registerEditorExtension();	// ç¼–è¾‘å™¨æ‰©å±•ï¼ˆå®æ—¶ç¼–è¾‘æ—¶ç”¨ï¼‰
    }
}
```



### Ad

`import type codemirror from "codemirror";`

```tsx
// è¶…ç®€åŒ–ç‰ˆä»£ç 
export default class ObsidianAdmonition extends Plugin {
    this.app.workspace.onLayoutReady(async () => {
        this.addChild

        this.registerEditorSuggest(); // ç¼–è¾‘å»ºè®®

        Object.keys(this.admonitions).forEach((type) => {
            this.registerType(type);
        });

        this.addSettingTab(); // è®¾ç½®

        this.addCommand({name: "Collapse Admonitions in Note"}); // åŠ å‘½ä»¤
        this.addCommand({name: "Open Admonitions in Note"});
        this.addCommand({name: "Insert Admonition"});
        this.addCommand({name: "Insert Callout"});
    });

    registerType(){
        MarkdownPreviewRenderer.unregisterCodeBlockPostProcessor()
        this.registerMarkdownCodeBlockProcessor(); // ä»£ç å—å¤„ç†
        this.registerCommandsFor(admonition); // è¿™ä¸ªä¸æ˜¯åŸæ–¹æ³•ï¼Œè‡ªå·±å®šä¹‰çš„
	}
}
```

æ‹ä¸€ä¸‹è°ƒç”¨å…³ç³»

```js
    /** ã€æ‹ä¸€ä¸‹è°ƒç”¨å…³ç³»ã€‘
     * ä¸»å…¥å£onload() è°ƒç”¨
     *     registerType > this.registerMarkdownCodeBlockProcessorï¼ˆæ³¨å†Œä»£ç å—äº‹ä»¶ï¼‰ è°ƒç”¨
     *         postprocessorï¼ˆæ­¤å‡½æ•°ï¼Œåå¤„ç†å™¨ï¼‰è°ƒç”¨
     *             getAdmonitionElementï¼ˆè·å–Adå…ƒç´ ï¼‰
     *             renderAdmonitionContentï¼ˆæ¸²æŸ“Adå†…å®¹ï¼‰è°ƒç”¨
     *                 getAdmonitionContentElementï¼ˆè·å–Adå†…å®¹çš„å…ƒç´ ï¼‰
     */
```



### Table-Extended

==ï¼ˆè¯¦è§æ³¨é‡Šç‰ˆæºä»£ç ï¼‰==

ç”¨äº†Markdowm-itå·¥å…·

```tsx
// è¶…ç®€åŒ–ç‰ˆä»£ç 
export default class TableExtended extends Plugin {
    async onload(): Promise<void> {
        this.addSettingTab(new TableExtendedSettingTab(this.app, this));	// è®¾ç½®
        MarkdownPreviewRenderer.registerPostProcessor(this.processNativeTable);	// ï¼Ÿï¼Ÿï¼Ÿåå¤„ç†å™¨
        this.registerMarkdownCodeBlockProcessor("tx", this.renderFromMD);	// ä»£ç å—å¤„ç†
        this.registerMarkdownPostProcessor(this.processTextSection);	// mdåå¤„ç†å™¨ï¼ˆæ¸²æŸ“æ¨¡å¼ç”¨ï¼‰
    }
}
```

åå¤„ç†å™¨ï¼š

```tsx
processTextSection = (el: HTMLElement, ctx: MarkdownPostProcessorContext) => {
    // el contains only els for one block in preview;
    // el contains els for all blocks in export2pdf
    for (const child of el.children) {
      let p: HTMLParagraphElement;
      if (child instanceof HTMLParagraphElement) {
        p = child;
      } else if (
        child instanceof HTMLQuoteElement &&
        child.firstElementChild instanceof HTMLParagraphElement
      ) {
        p = child.firstElementChild;
      } else continue;

      let result;
      if (p.innerHTML.startsWith("-tx-")) {
        const src = getSourceMarkdown(el, ctx);
        if (!src) {
          console.warn("failed to get Markdown text, escaping...");
        } else if ((result = src.match(prefixPatternInMD))) {
          const footnoteSelector = "sup.footnote-ref";
          // save footnote refs
          const footnoteRefs = [
            ...el.querySelectorAll(footnoteSelector),
          ] as HTMLElement[];
          // footnote refs is replaced by new ones during rendering
          this.renderFromMD(src.substring(result[0].length), el, ctx);
          // post process to revert footnote refs
          for (const newRefs of el.querySelectorAll(footnoteSelector)) {
            newRefs.replaceWith(footnoteRefs.shift()!);
          }
          for (const fnSection of el.querySelectorAll("section.footnotes")) {
            fnSection.remove();
          }
        }
      }
    }
  };
```



## ä½¿ç”¨äº†CMæ¥å£

### Decorationç±»

#### cm6-Decoration

```js
corateView(view: EditorView): DecorationSet {
    /* æ³¨é‡Šæ‰è¿™ä¸ªå®é™…ä¸Šè£…é¥°å°†ä¸ä¼šè§¦å‘/æ›´æ–°ï¼Œé™¤éè§†å£æ”¹å˜ */
    // åªæœ‰åœ¨åˆå§‹åŠ è½½æ—¶ï¼Œæ‰ä¼šåŒæ—¶åœ¨æ‰€æœ‰çª—æ ¼/å¶/è§†å›¾/æ³¨é‡Šä¸Šè¿è¡Œ
    if (!view.hasFocus) {
        console.log("This Editor does not have focus so skip...", view, view.hasFocus);
        this.myPlugin.cm6LastEditorFocus = { file: this.getTFileFromView(view), focused: false };
        return Decoration.none;
    }
    
    /* ç°åœ¨ä¸éœ€è¦è¿™æ®µä»£ç ï¼Œä½†æ˜¯ä¿å­˜èµ·æ¥å¯ä»¥æ–¹ä¾¿åœ°è·å¾—æ´»åŠ¨çš„cmç¼–è¾‘å™¨ */
    const cmEditor = this.getCmEditorFromView(view);
    if (cmEditor) {
        const getCursor = cmEditor.getCursor();
        const getLine = cmEditor.getLine(getCursor.line);
        // console.log("getCursor:", getCursor);
        // console.log("getLine:", getLine);
    }
    
}
```

è·å–ä¸€äº›ä¸œè¥¿ (TFileå’ŒEditor)

```js
import { editorInfoField } from 'obsidian';	// æˆ‘åˆšå¼€å§‹è¿˜ä»¥ä¸ºæ˜¯ä¸ªå˜é‡ï¼ŒåŸæ¥æ˜¯ä¸ªStateField<MarkdownFileInfo>ç±»å‹çš„å¸¸é‡

getTFileFromView(view: EditorView): TFile {
    // ä»å½“å‰çš„EditorViewè·å–TFile
    const myTFile = view.state.field(editorInfoField).file;
    return myTFile;
}

getCmEditorFromView(view: EditorView): Editor | null {
    // è·å–CMç¼–è¾‘å™¨å¯¹è±¡ï¼Œç”¨äºæŠ“å–å…‰æ ‡ã€è¡Œç­‰
    const cmEditor = view.state.field(editorInfoField).editor;
    if (cmEditor) {
        return cmEditor;
    } else {
        return null;
    }
}
```

æ ¸å¿ƒ

```js
// Plugin
export default class MyPlugin extends Plugin {
    editorExtension: Extension[] = [];
    async onload() {
        this.registerEditorExtension(this.editorExtension);
    }
    // ã€å¯åŠ¨é«˜äº®ã€‘
    this.editorExtension.push(suggestionsExtension(this));
    this.app.workspace.updateOptions();
}

// ViewPlugin
const suggestionsExtension = (plugin: MyPlugin): ViewPlugin<PluginValue> => {
    return ViewPlugin.fromClass(
        // è¿™ä¸ªç±»æœ‰ä¸ªæ„é€ å‚æ•° view: EditorView
        class {
            decorations: DecorationSet;
            myPlugin: MyPlugin;

            // å¯¹äºæ¯ä¸ªè¢«æ‰“å¼€çš„æ–‡æ¡£ï¼Œéƒ½ä¼šæ‰§è¡Œä¸€æ¬¡
            constructor(view: EditorView) {}

            // å½“å‰ç„¦ç‚¹æ–‡æ¡£å‘ç”Ÿå˜åŒ–æ—¶ï¼ˆåŒ…æ‹¬å…‰æ ‡ä½ç½®çš„æ”¹å˜å’Œä¸Šä¸‹æ»šåŠ¨æ–‡æ¡£å¯¼è‡´çš„visibleRangesæ”¹å˜ï¼‰
            public update(update: ViewUpdate): void {}
        },
        {
            decorations: (view) => view.decorations,
            eventHandlers: {
                mousedown: (e: MouseEvent, view: EditorView) => {},
            },
        }
    );
};
```

å¸¸ç”¨è°ƒè¯•

```js
const editorView = view.editor.cm as EditorView;	// æ­¤viewéå½¼viewï¼Œæ­¤viewä¸æ˜¯EditorViewï¼Œä¸çŸ¥é“å“ªæ¥çš„
// æˆ–
const view = ViewPlugin.fromClass ä¸­çš„ view: EditorView
const myFile: TFile = view.state.field(editorInfoField).file;
// stringç±»
view.state.doc.toString()
for (const { from, to } of visibleRanges)
view.hasFocus
view.state.selection
const textToHighlight = view.state.sliceDoc(from, to)
const visibleRange = from-to, textToHighlight
const matchesToIgnore = textToHighlight.split(regExIgnore);
for (const eachPart of matchesToIgnore)
update: ViewUpdate    // æ‚¨å¯ä»¥åœ¨ `update()` æ–¹æ³•ä¸­æ·»åŠ  `console.log(update);` è¿™è¡Œä»£ç ä»¥åœ¨æ§åˆ¶å°ä¸­æ‰“å°æ‰€æœ‰çš„æ›´æ–°å†…å®¹
    
const cmEditor = view.state.field(editorInfoField).editor;
const cursor = cmEditor.getCursor();
```



#### Decoration å‹ç¼©ç‰ˆã€ç²¾ç®€ç‰ˆï¼ˆAnyBlockPlugin_betaï¼‰

```js
export default class AnyBlockPlugin extends Plugin {
  
	async onload() {
    this.registerEditorExtension(this.editorExtension(this));
	}

	editorExtension(plugin_this: AnyBlockPlugin) {
		return ViewPlugin.fromClass(
			class {
				decorations: DecorationSet;

				constructor(view: EditorView) {
					this.decorations = this.buildDecorations(/*plugin_this*/view);
				}

				update(update: ViewUpdate) {
					if (update.docChanged || update.viewportChanged) {
						this.decorations = this.buildDecorations(/*plugin_this*/update.view);
					}
        		}
        
                // @private
                buildDecorations(view: EditorView): DecorationSet {
                  const builder = new RangeSetBuilder<Decoration>();  // èŒƒå›´ç”Ÿæˆå™¨
                  let underlineDecoration: Decoration = Decoration.mark({    // æ ¸å¿ƒï¼Œè£…é¥°å››ä¸ªä¸»è¦æ–¹æ³•é‡Œçš„markæ–¹æ³• â€”â€” æ ‡è®°è£…é¥°
                    class: 'cm-suggestion-candidate',
                    attributes: {
                        'data-index-keyword': "X",
                        'data-position-start': `20`,
                        'data-position-end': `30`,
                    }
                  });
                  builder.add(20, 30, underlineDecoration)
                  return builder.finish();
                }
            },
            {
                decorations: (v) => v.decorations,
            },
		)
	}
}

```



#### Obsidian æ‰‹å†Œçš„ ViewPlugin æ¡ˆä¾‹

```js
import { syntaxTree } from "@codemirror/language";
import { RangeSetBuilder } from "@codemirror/state";
import {
  Decoration,
  DecorationSet,
  EditorView,
  PluginSpec,
  PluginValue,
  ViewPlugin,
  ViewUpdate,
  WidgetType,
} from "@codemirror/view";
import { EmojiWidget } from "emoji";

// åŸºæœ¬éƒ½æ˜¯è§„èŒƒå†™æ³•
class EmojiListPlugin implements PluginValue {
  decorations: DecorationSet;

  constructor(view: EditorView) {
    this.decorations = this.buildDecorations(view);
  }

  update(update: ViewUpdate) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = this.buildDecorations(update.view);
    }
  }

  destroy() {}

  // @Private
  buildDecorations(view: EditorView): DecorationSet {
    const builder = new RangeSetBuilder<Decoration>();

    for (let { from, to } of view.visibleRanges) {
      syntaxTree(view.state).iterate({
        from,
        to,
        enter(node) {
          if (node.type.name.startsWith("list")) {
            // Position of the '-' or the '*'.
            const listCharFrom = node.from - 2;

            builder.add(
              listCharFrom,
              listCharFrom + 1,
              Decoration.replace({
                widget: new EmojiWidget(),
              })
            );
          }
        },
      });
    }

    return builder.finish();
  }
}

const pluginSpec: PluginSpec<EmojiListPlugin> = {
  decorations: (value: EmojiListPlugin) => value.decorations,
};

export const emojiListPlugin = ViewPlugin.fromClass(
  EmojiListPlugin,
  pluginSpec
);

```













