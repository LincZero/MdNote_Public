# 吴恩达机器学习

# 目录

# 异常检测（Anomaly detection）

应用：发现异常事件，比如：

- 欺诈检测（fraud detection）。
  $x^{(i)}$是用户的活动
- 监视数据中心中的计算机。
  $x^{(i)}$是机器的特征，分别是内存占用、硬盘数、CPU负载、网络流量
- ……



## 原理

例子：用异常检测来查看正在制造的飞机发动机，可能存在的问题

$$
飞机发动机的特征：\\
x_1=生成热量\\
x_2=震动幅度\\
\cdots\\~\\

\begin{align}
训练集：&\{x^{(1)},x^{(2)},\cdots,x^{(m)}\}\\
新发动机：&x_{test}\\
\end{align}\\~\\

目标：看这台新的发动机和以前制造的发动机相似程度，并给出相似概率。\\
若概率p(x_{test})<\varepsilon，则判断有异常\\
若概率p(x_{test})\geq \varepsilon，则判断无异常
$$


![image-20220917161528045](02. 异常检测.assets/image-20220917161528045.png)

![image-20220917163119232](02. 异常检测.assets/image-20220917163119232.png)



## 实现

### 高斯 (正态) 分布（Gaussioan (Normal) Distribution）

这里 高斯分布（Gaussioan Distribution）和 正态分布（Normal Distribution）是一个意思
其图像是一个 钟形曲线（Bell-shaped curve）



> #### 公式
>

$$
~
\begin{aligned}
    p(x)=&\frac1{\sqrt{2\pi}\sigma}
    	e^{\frac{-(x-\mu)^2}{2\sigma^2}}\\
    =&\frac1{\sqrt{2\pi}\sigma}
    	\exp(\frac{-(x-\mu)^2}{2\sigma^2})\\
\end{aligned}\\~\\

\begin{aligned}
其中：&\\
    \mu：&均值\\
    \sigma：&标准差（sigmoid）\\
    \sigma^2：&方差
\end{aligned}
$$



> #### 图像

（其中图像的面积为1，表示概率和是1）

![image-20220918130338355](02. 异常检测.assets/image-20220918130338355.png)

![image-20220918130921758](02. 异常检测.assets/image-20220918130921758.png)



> #### 拟合
>

对于数据集 $\{x^{(1)},x^{(2)},\cdots,x^{(m)}\}$，我们先算出他的均值$\mu$和标准差$\sigma$，代入即可得到正态分布公式
$$
\begin{align}
    \mu=&\frac 1m\sum^m_{i=1}x^{(i)}\\
    \sigma^2=&\frac1m\sum^m_{i=1}(x^{(i)}-\mu)^2\\
    \sigma=&\sqrt{\sigma^2}
\end{align}
$$


### 多特征

前面的正态分布我们高中都学过，但学的都是对于只有一个特征的情况。多特征的情况下怎么去异常检测？
$$
\begin{align}
p(x)=&~p(x_1;u_1,\sigma_1^2)\times p(x_2;u_2,\sigma_2^2)\times\cdots p(x_n;u_n,\sigma_n^2)\\
=&\prod^n_{j=1} p(x_j;u_j,\sigma_j^2)
\end{align}
$$
因为每一个特制的正态分布曲线面积是一，所以概率相乘，总概率依然会是一



二元特征的图像：

![image-20220918150949322](02. 异常检测.assets/image-20220918150949322.png)



### 完整步骤、总结

- ① 选择n个特征$x_i$

- ② 拟合算出$\mu_1,\cdots,\mu_n,\sigma_1^2,\cdots,\sigma^2_n$​
  $$
  \begin{align}
      \mu=&\frac 1m\sum^m_{i=1}x^{(i)}\\
      \sigma^2=&\frac1m\sum^m_{i=1}(x^{(i)}-\mu)^2\\
      \sigma=&\sqrt{\sigma^2}
  \end{align}
  $$

- ③ 给一个新x，计算出$p(x)$​。
  $$
  \begin{align}
  p(x)=&\prod^n_{j=1} p(x_j;u_j,\sigma_j^2)\\
  =&\prod^n_{j=1}\frac1{\sqrt{2\pi}\sigma_j}e^{\frac{-(x_j-\mu_j)^2}{2\sigma_j^2}}\\
  =&\prod^n_{j=1}\frac1{\sqrt{2\pi}\sigma_j}\exp(-\frac{(x_j-\mu_j)^2}{2\sigma_j^2})
  \end{align}
  $$

- ④ 判断是否异常
  $$
  若概率p(x_{test})<\varepsilon，则判断有异常\\
  若概率p(x_{test})\geq \varepsilon，则判断无异常
  $$



完整步骤图：

![image-20220918150955724](02. 异常检测.assets/image-20220918150955724.png)



## 选择特征

选择特征，对于异常检测比监督学习更重要



非高斯的特征：

可以让不是高斯分布的特征，经过不同的转化，变成高斯分布

![image-20220918161047727](02. 异常检测.assets/image-20220918161047727.png)

可以调整变换方式（对数或幂方）和数值，直到符合正态分布为止

![image-20220918162206599](02. 异常检测.assets/image-20220918162206599.png)



## 评估

### 交叉验证

依然是使用交叉验证的方法，但会有点不同：

比如有

- 10000个好的引擎（y=0）
- 20个有缺陷的引擎（y=1）

那么分别拆出

- 训练集：6000个好的引擎
- 交叉集：2000个好的引擎，10个坏的引擎
- 测试集：2000个好的引擎，10个坏的引擎

或者

- 训练集：6000个好的引擎
- 交叉集：4000个好的引擎，20个坏的引擎
- 测试集：不设置测试集



### $\varepsilon$值的选择

根据交叉验证结果，可以用来选择$\varepsilon$的值（判断是否异常的阈值）

需要注意：坏的引擎也属于罕见类。除了准确率外，也需要使用精确率和召回率来判断模型的好坏



### 异常检测的错误分析

多特征时，我们可能可以发现，是哪一个特征主要引起的异常

![image-20220918162833977](02. 异常检测.assets/image-20220918162833977.png)



比如数据中心的电脑检测，可以发现是内存、硬盘、CPU、网络等有异常

除了这些一维特征外，甚至可以分析$\frac{CPU负载}{网络流量}$或$\frac{(CPU负载)^2}{网络流量}$引起的异常原因



## 异常检测 vs 监督学习

> ##### 各自的优缺点

异常检测：

- 只有非常少的正例，有大量的反例

  （正例 y=1 表示异常，数量比如只有0~20个，反例 y=0 表示正常）

- 正例与正例之间可能是不相似的

  有许多不同 “类型” 的 “异常” ，
  都很难从正例中了解异常是什么样子的，未来的异常现象可能与我们目前看到的异常现象完全不同

  比如层出不穷的骗局、新型诈骗

监督学习：

- 有大量的正例和反例

- 正例与正例占是相似的

  有足够多的正例让算法知道正例是什么样的，且未来的正例可能和训练集中的相似

  比如垃圾邮件



> ##### 常见应用上

异常检测：

- 欺诈检测
- 制造业 - 在制造过程中发现以前未曾见过的新缺陷
- 安全 - 数据中心中的监视机器

监督学习：

- 电子邮件垃圾邮件分类
- 制造业 - 发现已知的、先前发现过的缺陷
- 天气预报（晴天/多雨/等）
- 疾病检测























