# Different

# 目录

# 类中函数

## 成员/方法访问控制

### 访问控制关键字

- C++
  - public、private关键字写在一组实例域和方法之前
  - 访问控制关键字写在头文件而不写在实现文件中
- Java
  - public、private关键字写在每一个实例和方法之前
  - 没有头文件、访问控制关键字直接写在实现文件中

### static 静态方法

好像C++中只有static方法才能操作static成员，但Java中似乎没有此限制

Java中的静态域与静态方法在功能上与C++相同。但是，语法书写上却稍有所不同。

- Java：无需构造对象。使用`.`操作符直接访问，如`Math.pow`
- C++：无需构造对象。使用`::`操作符访问自身作用域之外的静态域和静态方法，如`Math::PI`

## 构造和析构函数

### 构造函数

构造器名

- C++、Java：构造器名和类同名
- Java：构造器名为`init`

#### 显式域初始化

与C++相似地：

- Java：可以在执行构造器之前，先执行赋值操作

  ```java
  class Employee
  {
      private String name = "";
      // ...
  }
  ```

- C++：

  C++11也可以进行`类内初始化`（C++前不能），也有功能相似的`成员初始化列表`（Java没有）

  ```c++
  class Employee
  {
      Employee::Employee(String n, double s, int y, int m, int d)
          :name(n), salary(s), hireDay(y,m,d)
      {
          // ...    
      }
  }
  ```

#### 参数名命名习惯

==与C/C++不同==：成员函数参数命名习惯

- C++

  - 经常用下划线或某个固定的字母（一般选用m或x）作为实例域的前缀
  - 例如，_salary、mSalary或xSalary

- Java

  - 程序员则喜欢在每个参数前面加上一个前缀“a”

    ```java
    public Employee(String aName, double aSalary)
    {
        name = aName;
        salary = aSalary;
    }
    ```

  - 还一种常用的技巧，它基于这样的事实：参数变量用同样的名字将实例域屏蔽起来

    ```java
    public Employee(String name, double salary)
    {
        this.name = name;
        this.salary = salary;
    }
    ```

#### 构造器调用构造器

- C++：一个构造器不能调用另一个构造器（你确定不能？）。在C++中，必须将抽取出的公共初始化代码编写成一个独立的方法
- Java：可以，调用构造器的具体处理步骤如下
  1. 所有数据域被初始化为默认值（0、false或null）
  2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
  3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
  4. 执行这个构造器的主体

### 析构函数

- C++：有显式的析构器方法：`~`+类名

- Java：有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器

  当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。

  可以为任何一个类添加`finalize`方法。finalize方法将在垃圾回收器清除对象之前调用

## 其他函数

### 更改器方法与访问器方法（C++中的const成员函数）

访问器方法和静态方法

- Java：只访问对象而不修改对象的方法有时称为`访问器方法`（accessor method）
  例如：LocalDate.getYear和GregorianCalendar.get就是访问器方法。
  在Java语言中，访问器方法与更改器方法在**语法上没有明显的区别**
- C++：带有const后缀的方法是访问器方法；默认为更改器方法。
  但C++中似乎没有这种叫法，只是简单称为const成员函数

### 内联方法？

- C++
  - 通常在类的外面定义方法
  - 如果在类的内部定义方法，这个方法将自动地成为内联（inline）方法。
- Java
  - 所有的方法都必须在类的内部定义
  - 但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。
    即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。

### 方法参数

- Java：程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝。方法不能修改传递给它的任何参数变量的内容

  但注意的是：Java的对象实例本来就是对象的引用，按值引用后依然是对象的引用。可以通过对象方法修改对象实例所引用的对象

- C++：可以自由选择按值调用（call by value）或按引用调用（call by reference）

  例如：`void tripleValue(double&x)`，一个方法是按值调用还是按引用调用需要看函数原型才能知道

- 不可单纯将Java的对象实例理解为C++的引用，而必须要看成指针

  - 比如：不能编写一个交换两个雇员对象的方法，因为交换的只是拷贝进方法中的两个对象实例的地址，而并不能改变外部的两个对象实例的地址

