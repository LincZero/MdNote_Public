# 泛操作

## 变量

内存中的一个数据存储表示

### 声明定义、赋值、使用

由于有 默认初始化，这里不区分 声明与定义

main.go

```go
package main
import "fmt"

func main() {
    var age int 				// 变量声明
    age = 18					// 变量赋值
    fmt.Println("age = ", age)	// 变量使用
    
    var age2 int = 18; 			// 变量的声明和赋值可以合在一起
}
```

### 其他语法糖或特性

main.go

```go
var num1 int = 18	// 声明并赋值
fmt.Println(num1)

var num2 int		// 自动初始化
fmt.Println(num2)

var str1 = "18"    	// 自动类型推导
fmt.Println(str1)

str2 := "hello"		// 省略var，注意不能忽略冒号
fmt.Println(str2)

var n1, n2, n3 int	// 多个变量声明
var n4, n5, n6 = 10, "jack", 7.8
n7, n8 := 10, "duck"
```

全局与局部变量

```go
package main
import(					// 批量声明的语法糖 (引入)
    "fmt"
    "unsafe"
)

var n1 int = 0			// 全局变量

var (					// 批量声明的语法糖 (类型声明)
    n9 = 500
    n10 = "netty"
)

func main() {
    var n2 int = 1		// 局部变量
}
```

> 个人吐槽：
>
> 说好的语言特点是只有一种写法，但写法有的是比其他语言少……而有的语法糖反而比其他语言还多了……。少掉的东西中：
>
> 部分是像 编译强制初始化这种是更根本的东西，
>
> 但大部分则是一些换行和空格这种仅编码风格的约束。有种设计者强制所有人共用同一个 `.clang-format` 或者 `eslint`，且不符合则不给编译通过，的这种感觉。
> 符合我平时的写法我会觉得早该这么做了，否则我就感觉设计者闲得蛋疼，加这种约束闲得没事干）

下面是更详细的补充：

#### 自动初始化

复习下：

**与其他语言不同**：

> - 有默认初始化
>   - Java / Kotlin / Python / Swift / Go
>     - 基本类型：默认初始化为零值
>     - 对象引用：默认初始化为空 (java为null，kotlin为null，python为None，swift为nil，go为nil)
>   - TypeScript/JavaScript：
>     - 默认初始化为 undefined
> - 强制初始化
>   - Rust
>     - 强制初始化，否则报错，不存在默认初始化的行为
> - 无默认初始化
>   - C/C++（**这一类就只有C/C++了，hhhh**）
>     - 基本类型：无默认初始化，成员变量也是。使用这些变量是未定义行为，且无物理内存及虚拟内存对应的值是随机的
>     - 全局变量/静态变量：默认初始化为零值

Go的默认值：

| 数据类型   | 默认值 |
| ---------- | ------ |
| 整数类型   | 0      |
| 浮点类型   | 0.0    |
| 布尔类型   | false  |
| 字符串类型 | ""     |

#### 自动类型推导

**与其他语言不同**：

更类似于typescript语言，像C++是需要用auto关键字的

#### 初始化检查

```go
var n1 int8 = 2.3			// 编译错误，类型不符
var n2 int8 = int12 + 128	// 编译错误，超出界限
```

#### 省略var写法 (:= 写法)

#### 批量声明写法

### 类型转换

Go只有强制转换，没有隐式转换，哪怕小类型转大类型。

语法上 T(v) 就可以了，和其他语言类似，也会出现类型缩窄

#### 数字类型转化

```go
var n1 int = 100
var n2 float32 = n1				// 报错
var n2 float32 = float32(n1)	// 正确

var n5 int32 = 12
var n6 int64 = n5 + 30			// 报错
var n6 int64 = int64(n5) + 30	// 正确
```

#### 数值与string 互相转化

两种方式：

1. fmt包的Sprinf函数：fmt.Sprintf("%参数", 表达式)，C语言中也有一个类似的函数

   ```go
   // 数值转string
   var n1 int = 19
   var s1 string = fmt.Sprintf("%d", n1)
   fmt.Printf("s1类型 %T，值 %v", s1, s1)	// 类型 string，值 19
   
   // string转数值
   该方式没办法
   ```

2. strconv包的函数

   ```go
   // 数值转string
   // 原型
   func FormatBool(b bool) string
   func FormatInt(i int64, base int) string	// base意思是几进制的
   func FormatUint(i uint64, base int) string
   func FormatFloat(f float64, fmt byte, prec, bitSize int) string
   
   // 使用
   import(
       "fmt"
       "strconv"
   )
   func main(){
       var n1 int = 18
       var s1 string = strconv.FormatInt(int64(n1), 10)
       fmt.Printf("s1类型 %T, 值 %q\n", s1, s1)	// string "18"
       
       var n2 float64 = 3.14
       var s2 string = strconv.FormatInt(n2, 'f', 9, 64)
       fmt.Printf("s2类型 %T, 值 %q\n", s2, s2)	// string "3.14"
   }
   
   // string转数值
   // 原型
   // 注意：与其他语言不同：这里可以双返回值，有点类似于Python的返回元组，而C/C++就做不到这点。传统的C/C++在这方面，错误处理要么通过抛出异常，要么通过errno，不太舒服
   func ParseBool(str string) (value bool, err error)
   func ParseInt(s string, base int, bitSize int) (i int64, err error)
   func ParseUint(s string, base int, bitSize int) (n uint64, err error)
   func ParseFloat(s string, bitSize int) (f float64, err error)
   
   // 使用
   import(
       "fmt"
       "strconv"
   )
   func main(){
       var s1 string = "ture"
   	var b1 bool
       b1, _ = strconv.ParseBool(s1)				// 这里可以忽略第二个返回值，即忽略错误
       fmt.Printf("b类型 %T, 值 %v\n", b1, b1)	  // bool true
       
       var s2 string = "19"
   	var n1 int64
       n1, _ = strconv.ParseInt(s1, 10, 64)		// 这里可以忽略第二个返回值，即忽略错误
       fmt.Printf("n1类型 %T, 值 %v\n", n1, n1)	  // int64 19
       
       var s3 string = "go"
   	var b3 bool
       b3, _ = strconv.ParseBool(s3)				// 这里是错误的，但忽略了错误。此时没转化成功，b3会被赋予默认值，即零值
       fmt.Printf("b类型 %T, 值 %v\n", b3, b3)	  // bool false
   }
   ```

在数值转string中，似乎fmt.Sprintf的方式会简单一些

## 类型/占用内存打印

```go
package main
import "fmt"
import "unsafe"

func main(){
    var num3 = 28
    fmt.Printf("num3的类型是 %T", num3)   // int
    fmt.Println(unsafe.Sizeof(num3))	// 8 (Byte)
}
```

## 运算符

**与其他语言不同**：

- Go的整除是向零而非向下取整
- 极大限制了C/C++/Java的++/--骚操作，只能单独一个表达式使用，且只能放在变量后面
  （个人吐槽：对于学生来说好耶，但老程序员感觉这不是很爽）

几乎和其他语言一样，这里没有三目运算符

```go
// 1. 算数运算符
+, -, *, /, %, ++, --	// 相同点：整数除法也是整除，也有逻辑运算符也有短路
// 2. 赋值运算符
=, +=, -=, *=, /=, %=
// 3. 关系运算符
==, !=, <, >, <=, >=
// 4. 逻辑运算符
&&, ||, !
// 5. 位运算符
&, |, ^
// 6. 其他运算符
&, *
```

优先级：（越靠前越优先，反正我也懒得记，不常用不记得的就加括号）

| 分类                               | 运算符       | 结合性       |
| ---------------------------------- | ------------ | ------------ |
| 后缀运算符 (伪单目)                | `()、[]、->` | 从左到右     |
| **单目运算符**                     |              | **从右到左** |
| 算数运算符 (乘除取余 > 加减)       |              | 从左到右     |
| 位移运算符                         |              | 从左到右     |
| 关系运算符                         |              | 从左到右     |
| 相等/不相等                        |              | 从左到右     |
| 按位运算 (与 > 异或 > 或)          |              | 从左到右     |
| 逻辑运算符 (与 > 或，非归类到单目) |              | 从左到右     |
| 赋值运算符                         |              | **从右到左** |
| 逗号运算符                         |              | 从左到右     |















