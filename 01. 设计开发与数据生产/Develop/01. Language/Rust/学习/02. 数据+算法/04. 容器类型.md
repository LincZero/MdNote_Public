# Rust容器类型

## 元组 (tuple)

### 性质

Tuple 元组是一个 复合类型 ，可以存储多个不同类型的数据。 Rust 支持元组 tuple 类型。元组使用括号 () 来构造（construct）。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。

虽然名字叫 "元组"，不是数组（同类型），声明上也有点像Python的元组（变长、不同类型），但其实更类似于**C的结构体**（定长、不同类型），

- 元组是**定长**的。一旦定义，就不能再增长或缩小，长度是固定的。元组的下标从 0 开始
- 可以包含**不同的类型**

字符串对象在堆中，而元组在栈中

### 定义元组

```rust
let tuple变量名称:(数据类型1,数据类型2,...) = (数据1，数据2，...);
let tuple变量名称 = (数据1，数据2，...); // 自动推断类型
```

** 注：tuple 使用一对小括号 () 把所有元素放在一起，元素之间使用逗号 , 分隔。如果显式指定了元组的数据类型，那么数据类型的个数必须和元组的个数相同，否则会报错。**

```rust
fn main() {
    let t:(&str, &str) = ("Go语言极简一本通", "掌握Go语言语法，并且可以完成单体服务应用");
    println!("{:?}", t);
}
```

### 方法

#### 访问元素

```rust
元组变量.索引数字
```

示例

```rust
let t:(&str, &str) = ("Go语言极简一本通", "掌握Go语言语法，并且可以完成单体服务应用");
println!("{}", t.0);	// 输出 Go语言极简一本通
println!("{}", t.1);	// 输出 掌握Go语言语法，并且可以完成单体服务应用
```

#### 元组作参数

元组一般是值传递

```rust
fn 函数名称(tuple参数名称:(&str, i32)) {}
```

示例

```rust
fn show_tuple(tuple:(&str, &str)){
    println!("{:?}",tuple);
}

let t:(&str, &str) = ("Go语言极简一本通", "掌握Go语言语法，并且可以完成单体服务应用");
show_tuple(t);			// 输出 ("Go语言极简一本通", "掌握Go语言语法，并且可以完成单体服务应用")
```

#### 元组解构

元组 ( tuple )解构 就是在 tuple 中的每一个元素按照顺序一个一个赋值给变量。使用 = ，让右边的 tuple 按照顺序给等号左变的变量一个一个赋值。

这点有点像Python

```rust
let (book, target) = t;
println!("{}", book);		// 输出 Go语言极简一本通
println!("{}", target);		// 输出 掌握Go语言语法，并且可以完成单体服务应用
```

## 数组

数组 是用来存储一系列数据，拥有相同类型 T 的对象的集合，在内存中是连续存储的。使用中括号 [] 来创建，且它们的大小在编译时会被确定。数组下标是从0 开始。数组是在栈中分配的，数组可以**自动被借用**成为 **切片(slice)**。

### 声明和初始化

```rust
let 变量名:[数据类型; 数组长度] = [值1, 值2, 值3, ...];	// 一般写法
let arr1:[&str; 3] = ["Go语言极简一本通", "Go语言微服务架构核心22讲", "从0到Go语言微服务架构师"];

let 变量名 = [值1, 值2, 值3, ...];					// 类型推导
let arr2 = ["Go语言极简一本通", "Go语言微服务架构核心22讲", "从0到Go语言微服务架构师"];

let 变量名:[数据类型; 数组长度] = [默认值, 数组长度];		// 快速初始化，有点类似Cpp的大括号初始化或python的?解析表达式数组
let arr3:[&str; 3] = [""; 3];
```

### 方法

#### 获取数组长度 len()

```rust
print!("{}", arr1.len());
```

#### 遍历数组

```rust
for item in arr1 {
   print!("充电科目: {}\n",item);
}
// 输出
充电科目: Go语言极简一本通
充电科目: Go语言微服务架构核心22讲
充电科目: 从0到Go语言微服务架构师

for item in arr1.iter(){
   print!("已参加的充电科目: {}\n",item);
}
// 输出
已参加的充电科目: Go语言极简一本通
已参加的充电科目: Go语言微服务架构核心22讲
已参加的充电科目: 从0到Go语言微服务架构师
```

如果修改一个不可变数组，报错如下：

```rust
arr2[0] = "";
error[E0594]: cannot assign to `arr2[_]`, as `arr2` is not declared as mutable
```

如果想修改这个错误，声明数组的时候，添加 mut 关键字

#### 数组做参数

**值传递** 传递一个数组的副本，副本的修改，不会影响原数组。

```rust
fn show_arr(arr:[&str;3]){
    let l = arr.len();
    for i in 0..l {
        if i==0 {
            arr[0] = ""
        }
        println!("充电科目: {}",arr[i]);
    }
} 

let mut arr2 = ["Go语言极简一本通", "Go语言微服务架构核心22讲", "从0到Go语言微服务架构师"];
 print!("{:?}\n", arr2);
 show_arr(arr2);
 print!("{:?}\n", arr2);

// 输出
["Go语言极简一本通", "Go语言微服务架构核心22讲", "从0到Go语言微服务架构师"]
充电科目: 
充电科目: Go语言微服务架构核心22讲
充电科目: 从0到Go语言微服务架构师
["Go语言极简一本通", "Go语言微服务架构核心22讲", "从0到Go语言微服务架构师"]
```

引用传递 传递内存的地址给函数，修改数组的任何值都会修改原来的数组。

```rust
fn modify_arr(arr:&mut [&str;3]){
    let l = arr.len();
    for i in 0..l {
        arr[i]="";
    }
}

let mut arr3=["Go语言极简一本通","Go语言微服务架构核心22讲","从0到Go语言微服务架构师"];
print!("{:?}\n",arr3);
modify_arr(&mut arr3);
print!("{:?}\n",arr3);

// 输出
["Go语言极简一本通", "Go语言微服务架构核心22讲", "从0到Go语言微服务架构师"]
["", "", ""]
```

