# Java

# 目录

# 数值类型+低内存类型（java.lang包）

## 泛操作

### 运算符

#### +-*/%，加减乘除余

与Python区别

- Java/C/C++：当参与/运算的两个操作数都是整数时，表示整数除法；否则，表示浮点除法
- Python：`/`必然是浮点除法，`//`是整除法

扩展小知识

> strictfp关键字严格计算，禁止对中间计算结果采用扩展的精度，能使浮点运算在所有计算机上运行的结果都完全一样

#### 骚操作

二元运算符改一元运算符

```java
x += 4;
n++;
```

### 运算类

#### Math类

```java
import static java.lang.Math.*	// 加了的话就不用再加前缀 “Math.”
    
double y = Math.sqrt(x);		// 开方
double y = Math.pow(x, a);		// 幂
double y = Math.floorMod(x, a);	// 向下取余（n%2求余有个bug是计算负数时会求得0/-1，不方便判断奇偶）
double y = Math.round(x);		// 圆整
常用的其他方法 {
	Math.sin
    Math.cos
    Math.tan
    Math.atan
    Math.atan2
    Math.exp
    Math.log
    Math.log10
    Math.PI
    Math.E
}
```

扩展

> println方法和sqrt方法存在微小的差异。println方法处理System.out对象。但是，Math类中的sqrt方法处理的不是对象，这样的方法被称为静态方法。

#### StrictMath类

在Math类中，为了达到最快的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用StrictMath类。

它使用“自由发布的Math库”（fdlibm）实现算法，以确保在所有平台上得到相同的结果。

## 整型

| 类型  | 存储需求 | 取值范围           |
| ----- | -------- | ------------------ |
| int   | 4 字节   | -21亿 ~ 21亿       |
| short | 2 字节   | -32768 ~ 32768     |
| long  | 8 字节   | -920亿亿 ~ 920亿亿 |
| byte  | 1 字节   | -128 ~ 127         |

表示进制数：

- 十六进制：有一个前缀0x或0X（如0xCAFE）
- 八进制：有一个前缀0，例如，010对应八进制中的8。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数
- 二进制：加上前缀0b或0B就可以写二进制数。例如，0b1001就是9（从Java 7开始）

补充

- ==与C/C++不同==
  - C/C++：分有符号数和无符号数
  - Java：没有任何无符号（unsigned）
  - Python3：数字的类型更少（四种：int、float、bool、complex（复数））
    其中int为变长类型，理论可以无限大。甚至没有long这种类型（python2依然有long类型）
- 字面两下划线
  从Java 7开始，还可以为数字字面量加下划线。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。
  如用1_000_000（或0b1111_0100_0010_0100_0000）表示一百万。

## 浮点类型

| 类型   | 存储需求 | 取值范围                                          |
| ------ | -------- | ------------------------------------------------- |
| float  | 4 字节   | 大约 +-3.40282347E+38F（有效位数6~7位）           |
| double | 8 字节   | 大约 +-1.79769313486231570E+308（有效位数为15位） |

float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。

浮点数值不适用于无法接受舍入误差的金融计算中。如果在数值计算中不允许有任何舍入误差，就应该使用`BigDecimal类`

## char类型

存储大小为一字节

char类型原本用于表示单个字符。不过，现在情况已经有所变化。
如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值

用单引号括起来。例如：'A'是编码值为65所对应的字符常量。

转义字符表

| 转义序列 | 名称   | Unicode值 |
| -------- | ------ | --------- |
| \b       | 退格   | \u0008    |
| \t       | 制表   | \u0009    |
| \n       | 换行   | \u000a    |
| \r       | 回车   | \u000d    |
| \"       | 双引号 | \u0022    |
| \'       | 单引号 | \u0027    |
| \\       | 反斜杠 | \u005c    |

注意

> Unicode转义序列会在解析代码之前得到处理。
> 例如，"\u0022+\u0022"并不是一个由引号（U+0022）包围加号构成的字符串。
> 实际上，\u0022会在解析之前转换为"，这会得到""+""，也就是一个空串

## boolean类型

有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。

在C++中，数值甚至指针可以代替boolean值。值0相当于布尔值false，非0值相当于布尔值true。在Java中则不是这样。

因此，Java程序员不会遇到下述麻烦：`if(x=0)`

### 布尔运算符

```java
==, !=
<, >, <=, >=
&&, ||, !

三元运算符 condition ? exp1 : exp2
```

### 位运算符

```java
&	// and
|	// or
~	// not
^	// xor 异或
    
>>	// 右移，用符号位填充高位
<<	// 左移
>>>	// 右移，用0填充高位，这与>>不同，它会用符号位填充高位
```

==与C/C++不同==

> - C/C++：不能保证>>是完成算术移位（扩展符号位）还是逻辑移位（填充0）
> - Java：消除了这种不确定性，这与java中没有无符号类型有关。`>>`用符号位填充高位，`>>>`用0填充高位

### 括号与运算符级别

[省略]

==与C/C++不同==：Java不使用逗号运算符。不过，可以在for语句的第1和第3部分中使用逗号分隔表达式列表

# 数值类型+低内存类型（其他包）

## BigInteger+BigDecimal

API: `java.math.BigInteger 1.1`、`java.math.BigDecimal`

- BigInteger类实现了任意精度的整数运算
- BigDecimal实现了任意精度的浮点数运算

```java
BigInteger a = BigInteger.valueOf(100);						// 类型转换
BigInteger c = a.add(b);									// c = a+b，不能用运算符+了
BigInteger d = c.multiply(b.add(BigInteger.valueOf(2)));	// d = c*(b+2)
```

==与C/C++不同==：运算符重载

- Java没有提供运算符重载功能。程序员无法重定义+和*运算符，使其应用于BigInteger类的add和multiply运算





























