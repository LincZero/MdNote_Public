# 设备控制器 (Device Control)

## 提前总结

### 总结

- 物理设备
  - 设备控制器
    - 主要作用：**统一的标准化管理**，屏蔽设备差异

    - 交互方式：CPU 通过读写设备控制器中的寄存器控制设备，这可比 CPU 直接控制输入输出设备，要方便和标准很多

    - 位置：**每个设备都有一个**

    - 举例：硬盘有硬盘控制器、显示器有视频控制器等

### 架构图

![计算机 I/O 系统结构](01.%20设备控制器.assets/I_O系统结构.png)

## 作用

我们的电脑设备可以接非常多的输入输出设备，比如键盘、鼠标、显示器、网卡、硬盘、打印机、音响等等，每个设备的用法和功能都不同，那操作系统是如何把这些输入输出设备统一管理的呢?

为了屏蔽设备之间的差异，**每个设备都有**一个叫 **设备控制器（*Device Control*）** 的组件



因为这些控制器都很清楚的**知道对应设备的用法和功能**，所以 CPU 是通过设备控制器来和设备打交道的。

设备控制器里有芯片，它可执行自己的逻辑，也有自己的寄存器，用来与 CPU 进行通信，比如：

- 通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。
- 通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。

## 实现细节 - 三类寄存器 (状态/命令/数据)

实际上，控制器是有三类寄存器，它们分别是：

- **状态寄存器（*Status Register*）**，CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I/O 设备。
- **命令寄存器（*Command Register*）**，CPU 发送一个命令，告诉 I/O 设备，要进行输入/输出操作，于是就会交给 I/O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。
- **数据寄存器（*Data Register*）**，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。

如下图：

![img](01.%20设备控制器.assets/设备控制器.png)

## 实现细节 - 两类输出设备 (块/字符)

另外， 输入输出设备可分为两大类 ：

- **块设备（*Block Device*）**，把数据存储在固定大小的块中，每个块有自己的地址
  - 例如：硬盘、USB 是常见的块设备
- **字符设备（*Character Device*）**，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作
  - 例如：鼠标是常见的字符设备



其中，由于 **块设备** 通常传输的数据量会非常大，于是控制器设立了一个可读写的 **数据缓冲区**。这样做是为了，**减少对设备的频繁操作**。

- 写入：CPU 写入数据到控制器的缓冲区时，当缓冲区的数据 *囤够了一部分，才会发给设备*
- 读取：CPU 从控制器的缓冲区读取数据时，也需要缓冲区 *囤够了一部分，才拷贝到内存*

## 两个通信方法 (端口/内存映射)

那 CPU 是如何与设备的控制寄存器和数据缓冲区进行通信的？存在两个方法：

- **端口 I/O**：每个控制寄存器被分配一个 I/O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 `in/out` 类似的指令。
- **内存映射 I/O**：将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。



