# 通用块层

## 提前总结

### 总结

通用块层

- 总作用
  - 管理块设备。为了减少不同块设备的差异带来的影响，Linux 通过一个统一的 通用块层，来管理不同的块设备。
- 具体功能
  1. 提供访问块设备的标准接口
  2. IO调度

### 架构图

通用块层是 **处于文件系统和磁盘驱动中间的一个块设备抽象层**

![img](04.%20通用块层.assets/I_O软件分层.png)

## 功能

它主要有两个功能：

1. 提供标准接口
   - 向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种**不同的磁盘设备抽象为统一的块设备**，并在内核层面，提供一个框架来管理这些设备的驱动程序；

2. IO调度
   - 通用层还会给文件系统和应用程序发来的 I/O 请求排队，接着会对队列重新排序、请求合并等方式，也就是 **I/O 调度**，主要目的是为了**提高磁盘读写的效率**。
   - （但话说 “存储系统分层图” 里不是还有个块设备IO调度层嘛？不应该是那个负责的才对吗？）

##  5 种 I/O 调度算法

Linc：《小林图解里对这部分的描述不和很详细》，此处可以另外找资料补充下。

另参考：

- [Linux IO Scheduler（Linux IO 调度器） ](https://www.cnblogs.com/liushuhe1990/articles/11141172.html)
- [io调度算法【转】](https://www.cnblogs.com/sky-heaven/p/16423372.html)

### 5种IO调度算法

Linux 内存支持 5 种 I/O 调度算法，分别是：

1. **没有**调度算法 (NOOP, No Operation，又称电梯调度算法)
   - 原理：不对文件系统和应用程序的 I/O 做任何处理
   - 适用：*虚拟机 I/O* 比较常用，此时磁盘 I/O 调度算法交由物理机系统负责
2. **先入先出**调度算法
   - 原理：先进入 I/O 调度队列的 I/O 请求先发生
   - 优点：这是最简单的 I/O 调度算法
3. **完全公平**调度算法 (CFQ, Completely Fair Queuing，完全公平排队)
   - 原理：它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求
   - 适用：*大部分系统*  都把这个算法作为默认的 I/O 调度器
4. **优先级**调度算法
   - 原理：顾名思义，优先级高的 I/O 请求先发生
   - 适用：*运行大量进程的系统*（像是桌面环境、多媒体应用等）（我记得桌面系统往往会有意将显示IO的优先级调高/低，避免画面卡死/降帧优化性能）
5. **最终期限**调度算法
   - 原理：分别为读、写请求创建了不同的 I/O 队列
   - 优点：这样可以提高机械磁盘的吞吐量，并确保达到最终期限的请求被优先处理
   - 适用：*I/O 压力比较大的场景*（比如数据库等）

### IO调度器

1. NOOP
2. CFQ (Completely Fair Queuing，完全公平排队)
3. DEADLINE：在CFQ基础上接触IO饿死问题
4. Anticipatory

### 修改IO调度算法

在RHEL5/OEL5以及之后的版本中（比如RHEL6和RHEL7），可以针对每块磁盘制定I/O Scheduler，修改完毕立刻生效，比如：

```bash
$ cat /sys/block/sda1/queue/scheduler
[noop] anticipatory deadline cfq

#修改为cfq
$ echo 'cfq'>/sys/block/sda1/queue/scheduler

#立刻生效
$ cat /sys/block/sda1/queue/scheduler
noop anticipatory deadline [cfq]
```

![image](04.%20通用块层、IO调度算法.assets/ae4363a7c56c01613089ff67270b9a21.png) 

![image](04.%20通用块层、IO调度算法.assets/2f4550ee9e8461a237c1adc5bd6a0775.png)







