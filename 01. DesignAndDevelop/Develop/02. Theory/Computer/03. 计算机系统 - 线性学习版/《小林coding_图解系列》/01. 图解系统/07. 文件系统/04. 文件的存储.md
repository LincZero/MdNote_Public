# 文件的存储

文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：

- 连续空间存放方式
- 非连续空间存放方式

其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。

不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。

## (1) 连续空间存放方式

提前总结：

- 实现
  - 文件头里指定起始块位置和长度
- 优点
  - 读写效率很高
- 缺点
  - 删除文件，则磁盘空间碎片
  - 追加文件，则文件长度不易扩展

> ##### 方式

连续空间存放方式顾名思义，**文件存放在磁盘「连续的」物理空间中**。

使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。

所以，**文件头里需要指定「起始块的位置」和「长度」**，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。

注意，此处说的文件头，就类似于 Linux 的 inode。

![连续空间存放方式](04.%20文件的存储.assets/连续空间存放方式.png)

> ##### 优点

这种模式下，文件的数据都是紧密相连，**读写效率很高**，因为一次磁盘寻道就可以读出整个文件。

连续空间存放的方式虽然读写效率高，**但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。**

> ##### 缺点 —— 磁盘空间碎片

如下图，如果文件 B  被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。

![磁盘碎片](04.%20文件的存储.assets/连续空间存放方式-磁盘碎片.png)

> ##### 缺点 —— 文件长度扩展不方便

另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。

## (2) 非连续空间存放方式

那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。

非连续空间存放方式分为「链表方式」和「索引方式」。

### 链表方式

链表的方式存放是 **离散的，不用连续的**，于是就可以 **消除磁盘碎片**，可大大提高磁盘空间的利用率，同时 **文件的长度可以动态扩展**。根据实现的方式的不同，链表可分为「**隐式链表**」和「**显式链接**」两种形式。

#### 隐式链接

提前总结：

- 实现
  - 文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置
- 优点
  - 解决连续空间不足：解决磁盘空间碎片和文件长度扩展不方便的问题
- 缺点
  - 访问慢：无法直接访问数据块，只能通过指针顺序访问文件
  - 空间损耗：以及数据块指针消耗了一定的存储空间
  - 稳定差：分配的稳定性较差，系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失

> ##### 实现

文件要以「**隐式链表**」的方式存放的话，**实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置**，这样一个数据块连着一个数据块，从链头开始就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。

![隐式链表](04.%20文件的存储.assets/非连续空间存放方式-链表方式.png)

> ##### 缺点

隐式链表的存放方式的**缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间**。隐式链接分配的**稳定性较差**，系统在运行过程中由于软件或者硬件错误**导致链表中的指针丢失或损坏，会导致文件数据的丢失。**

#### 显式链接、文件分配表 (FAT)

提前总结：

- 实现
  - 隐式链表基础上，取出每个磁盘块的指针，把它放在**内存**的一个**表 (文件分配表 FAT)** 中
- 优点
  - 解决连续空间不足：解决 产生磁盘空间碎片、文件长度不易扩展
  - 解决隐式链表不足：内存查询更快、空间更足、稳定更好
- 缺点
  - 不适用于大磁盘

> ##### 实现

如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「**显式链接**」，它指**把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中**，该表在整个磁盘仅设置一张，**每个表项中存放链接指针，指向下一个数据块号**。

对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4  块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B  的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1）结束。内存中的这样一个表格称为 **文件分配表（*File Allocation Table，FAT*）**。

![显式链接](04.%20文件的存储.assets/文件分配表.png)

> ##### 优点

由于查找记录的过程是在内存中进行的，因而不仅显著地 **提高了检索速度**，而且 **大大减少了访问磁盘的次数**

> ##### 缺点

但也正是整个表都存放在内存中的关系，它的主要的缺点是 **不适用于大磁盘**。

比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存。很显然 FAT 方案对于大磁盘而言不太合适。

### 索引方式

提前总结：

- 实现
  - 为每个文件创建一个「索引数据块」，文件头需要包含指向「索引数据块」的指针
  - 索引数据块里面存放的是指向文件数据块的指针列表，说白了就像书的目录一样
- 优点
  - 解决连续空间不足：解决 产生磁盘空间碎片、文件长度不易扩展
  - 解决链表不足：除顺序读写，还支持随机读写
- 缺点
  - 空间损耗：带来的额外空间开销

> ##### 实现

接下来，我们来看看索引的方式

链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。

索引的实现是为每个文件创建一个「**索引数据块**」，里面存放的是**指向文件数据块的指针列表**，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。

另外，**文件头需要包含指向「索引数据块」的指针**，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。

创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。

![索引的方式](04.%20文件的存储.assets/非连续空间存放方式-索引方式.png)

> ##### 优点

索引的方式优点在于：

- 文件的创建、增大、缩小很方便；
- 不会有碎片的问题；
- 支持顺序读写和随机读写；

> ##### 缺点

由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。

如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。

### 链表 + 索引（链式索引块）

先来看看链表 + 索引的组合，这种组合称为「**链式索引块**」，它的实现方式是**在索引数据块留出一个存放下一个索引数据块的指针**，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。

![链式索引块](04.%20文件的存储.assets/链式索引块.png)

### 索引 + 索引（多级索引块）

还有另外一种组合方式是索引 + 索引的方式，这种组合称为「**多级索引块**」，实现方式是**通过一个索引块来存放多个索引数据块**，一层套一层索引，像极了俄罗斯套娃是吧。

![多级索引块](04.%20文件的存储.assets/多级索引块.png)

## (3) 混合存放方式 (当前采用)

那早期 Unix 文件系统 (Ext) 是组合了前面的文件存放方式的优点，如下图：

![早期 Unix 文件系统](04.%20文件的存储.assets/Unix 多级索引.png)

它是根据文件的大小，存放的方式会有所变化：

- 如果存放文件所需的数据块小于 10 块，则采用**直接查找**的方式；
- 如果存放文件所需的数据块超过 10 块，则采用**一级间接索引**方式；
- 如果前面两种方式都不够存放大文件，则采用**二级间接索引**方式；
- 如果二级间接索引也不够存放大文件，这采用**三级间接索引**方式；

那么，文件头（*Inode*）就需要包含 13 个指针：

- 10 个指向数据块的指针；
- 第 11 个指向索引块的指针；
- 第 12 个指向二级索引块的指针；
- 第 13 个指向三级索引块的指针；

所以，这种方式能很**灵活地支持小文件和大文件的存放**：

- 对于小文件使用直接查找的方式可减少索引数据块的开销；
- 对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；

这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。

为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。

## 【比较】几种方式的比较

我们先把前面提到的文件实现方式，做个比较：

![img](04.%20文件的存储.assets/文件存储方式比较.png)

所以一般采用混合结合方案（像前面说的Unix文件方式Ext那样）：

- 小文件：使用直接查找的方式可减少索引数据块的开销；
- 大文件：以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；

## 【扩展】文件头

“文件头” 的两种含义：（可能翻译/简写问题，有时这会表示两种不同的概念）

- 文件头1：有时在语境中指文件内容中的头部部分，如压缩文件的头部可以看到真正的压缩格式而非后缀名（用十六进制打开文件可以看到）
- 文件头2：这章的文件头的语境，是包含起始块/长度/末尾块/索引数据块指针的东西，两者不一样



根据不同文件存储方案，文件头可能包含：

- 连续存放：起始块、长度
- 非连续存放
  - 链表方式：起始块、末尾块
  - 索引方式：索引数据块指针



文件头的位置：

- 文件头应该是包含在 inode 信息里的？









