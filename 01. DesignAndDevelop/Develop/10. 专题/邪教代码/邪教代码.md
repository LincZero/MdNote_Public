# 邪教代码

## 通用类

### 记时器排序

这个应该都知道，就不详细说了。就是数字几就sleep多久，最后会按顺序打印出来

## 位运算类

### 异或版 数据交换

- 有个好玩的点，可以用异或来交换（弹幕好像说，CSAPP里说现在这种写法性能没什么优势了）

- 异或，也是**无进位相加**（可以用这个来理解：为什么异或满足**交换率和结合率**），加法器也是异或实现，除了与或非外，这个最重要最好用了应该。

- 这三行跑完就交换了：

  ```c
  a = a^b;	// a = a原^b原，b=b原
  b = a^b;	// a = a原^b原，b = a原^b原^b原 = a原^0 = a原，这里使用了交换率或结合率
  a = a^b;	// a = a原^b原^a原 = b原，b = a原
  ```

- 注意有个致命缺点，这里有个前提，a和b的值可以相当，但不能是同一个内存，否则自己和自己异或会变成0

### 有符号负数，的取反加一

负数补码为反码加一

a-b = a+(-b的补数) = a+(mod-b)，（补码看作是无符号整形且>半模，即最高位为1）

取补码算法：0x1100 0110 为例

- 加减法：u0x1 0000 0000 - u0x0100 0110 = u0x1011 1010
- 按位运算法：人工取补码则是将b反码再加一，或者说最高位固定为1，其余取反并+1。如0x1100 0110 -> 0x_011 1001 -> u0x1011 1010

### 提取最右侧的一

有点类似于补码转化那种想法，但完全不同，这里首先就没有负数的概念，是另外一种。

代码实现里的一个细节技巧：`int rightOne = eor & (~eor+1);` 位运算，提取最右侧的一。

```cpp
eor == 		0x1010111100;
~eor == 	0x0101000011;
~eor+1 ==	0x0101000100;
eor & (~eor+1) == 0x0000000100;
```

## C++

### 无视私有变量

作者：C++与Qt技术交流群里的 @山东-卖女孩的小火柴 ，模板实例化的时候可以无视访问权限限定符拿私有变量的操作

![img](杂项.assets/1000d4ad9d5d97caadffc0f372fa43dc.png)























