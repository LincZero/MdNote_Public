# 《C++设计模式》视频_李建忠

# 目录

# 23种设计模式总结

## 分类总结

### 几种分类方式

- 从目的来看（《设计模式：可复用面向对象》中的分类）

  - |                  分类                  |                             中译                             |                           设计模式                           |
    | :------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    | 创建型模式<br />（Creational）<br />5  | 抽象工厂<br />构建器（生成器）<br />工厂方法<br />原型<br />单件 | Abstract Factory<br />Builder<br />Factory Method<br />Prototype<br />Singleton |
    | 结构型模式<br />（Structural）<br />7  | 适配器<br />桥接模式<br />组成<br />装饰<br />外观（门面）<br />享元<br />代理 | Adapter<br />Bridge<br />Composite<br />Decorator<br />Facade<br />Flyweight<br />Proxy |
    | 行为型模式<br />（Behavioral）<br />11 | 职责链<br />命令<br />解释器（解析器）<br />迭代器<br />中介者<br />备忘录<br />观察者<br />状态<br />策略<br />模板方法<br />访问者 | Chain of Responsibility<br />Command<br />Interpreter<br />Iterator<br />Mediator<br />Memento<br />Observer<br />State<br />Strategy<br />Template Method<br />Visitor |

- 从范围来看

  - 类模式：处理类与子类的静态关系（偏重继承方案）
  - 对象模式：处理对象间的动态关系（偏重组合方案）

- 从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时）

  - |   分类   |                           中译                           |                           设计模式                           |      目的分类      |
    | :------: | :------------------------------------------------------: | :----------------------------------------------------------: | :----------------: |
    | 组件协作 |          模板方法<br />策略模式<br />观察者模式          |      Template Method<br />Strategy<br />Observer/Event       |       行为型       |
    | 单一职责 |                  装饰模式<br />桥接模式                  |                    Decorator<br />Bridge                     |       结构型       |
    | 对象创建 | 工厂模式<br />抽象工厂<br />原型模式<br />~~构建器模式~~ | Factory Method<br />Abstract Factory<br />Prototype<br />Builder |       创建型       |
    | 对象性能 |                  单件模式<br />享元模式                  |                   Singleton<br />Flyweight                   | 创建型<br />结构型 |
    | 接口隔离 |  门面模式<br />代理模式<br />适配器<br />~~中介者模式~~  |         Facade<br />Proxy<br />Adapter<br />Mediator         | 结构型<br />行为型 |
    | 状态变化 |               状态模式<br />~~备忘录模式~~               |                      State<br />Memento                      |       行为型       |
    | 数据结构 |     组合模式<br />~~迭代器模式~~<br />~~职责链模式~~     |     Composite<br />Iterator<br />Chain of Responsibility     | 结构型<br />行为型 |
    | 行为变化 |             ~~命令模式~~<br />~~访问器模式~~             |                     Command<br />Visitor                     |       行为型       |
    | 领域问题 |                      ~~解析器模式~~                      |                         Interpreter                          |       行为型       |

### 分类总结

略

### 个人分类

前面提到过可以用不同的方式对这23种设计模式进行划分和分类

包括：

-   按目的来看（书上的3种）
-   按封装变化角度（李建忠的9种）
-   按范围来看（2种）
-   按启用的原则来看（8种，但一个设计模式会涉及多种原则）
-   按重构技法来看（5种，但一个设计模式会涉及多种原则）
-   按中间层来看（见下）

另外，从 Java 中也有一具话叫 “没有什么是加中间层不能解决的，如果有，就再加一层”。我认为我可以以 “中间层” 为切入点，再进行分类。
缺点是这种分类偏代码向，不够本质，归纳流于表面

有两种中间层提供方法

-   a和b之间直接提供。例如
    -   工厂模式：a create b 的中间添加中间层
    -   适配器模式
-   通过基类提供。a -> a基 -> b基 -> b，使用这种方法进行传递。
    有点类似封装变化点的原则、和晚绑定的技法















## 总概共同特点

- 一个目标：管理变化，提高复用！
- 两种手段
  - 分解
  - 抽象
- 八大原则
  - 依赖倒置原则（DIP）
  - 开放封闭原则（OCP）（开闭原则）
  - 单一职责原则（SRP）
  - 里氏代换原则（LSP）（Liskov代换原则 / 里斯科夫代换）
  - 接口隔离原则（ISP）
  - 合成复用原则（优先使用对象组合，而不是类继承）
  - 封装变化点
  - 面向接口编程，而不是面向实现编程
- 五种重构技法
  - 静态 --> 动态
  - 早绑定 --> 晚绑定
  - 继承 --> 组合
  - 编译时依赖 --> 运行时依赖
  - 紧耦合 --> 松耦合
- 类图的共同特点与趋向
  - 继承 --> 组合且是包含一个**抽象基类的指针**
  - `class A:B{}`（×）
  - `class A{B b}`（×）
  - `class A{B* pb}`（√）

- 什么时候不用模式（不要盲目模式、为了模式而模式）
  - 代码可读性很差时
  - 需求理解还很浅时
  - 变化没有显现时
  - 不是系统的关键依赖点
  - 项目没有复用价值时（比如对于做外包的）
  - 项目将要发布时
- 设计模式成长之路
  - "手中无剑，心中无剑”：见模式而不知
  - "手中有剑，心中无剑"：可以识别模式，作为应用开发人员使用模式
  - "手中有剑，心中有剑"：作为框架开发人员为应用设计某些模式
  - "手中无剑，心中有剑"：忘掉模式，只有原则

## 每种设计模式的要点

略

## 常见框架中的设计模式

### 模板模式 Template Method

- 这个太常见了，我就不举例了

### 观察者模式 Observer

- Java中的Listener机制
- C#的Event模式
- Qt的single-slot机制、Model-View模式
- Vue的核心——数据驱动视图（Observer模块）

### 中介者模式 Mediator

- 类似于MVVM（Model-View-ViewModel，模型-视图-视图模型）本质上就是MVC （Model-View-Controller，模型-视图-控制器 ）的改进版

- 类似于Vue（Vue中，`v-bind`/` :`应该用的是观察者模式，而`v-model`双向绑定应该是用的中介者模式）


### 单例模式 Singleton

- Qt的QPluginLoader的instance()方法
- Qt开发过程中的自定义类PluginManager也用到了这个模式

### 职责链模式 Chain of Responsibility

- Android的事件分发机制
- QT的消息传递机制

### 适配器模式 Adapter

- 原生Android开发的控件有用到过







